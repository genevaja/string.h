#include "./s21_string.h"

/*Отличие с printf в том что результат записывается не в стандартный поток вывода (stdout), а в строку.
 *При успешном возврате функция возвращает количество записанных символов, за исключением завершающего нулевого символа, 
 *используемого для завершения строки, при неуспешном возврате возвращает EOF.
 *В качестве первого аргумента sprintf получает на вход указатель на строку(str) куда будет записываться результат.
 *В качестве второго аргумента sprintf получает на вход указатель на постоянную строку(format). 
 *Строка format содержит в себе информацию о типе данных переменной, которая будут записаны в строку(str). 
 */

int s21_sprintf(char *str, const char *format, ...) {
    char *end = str;
    end[0] = '\0';
    s21_memset(end, '\0', sizeof(end));
    va_list argptr;
    va_start(argptr, format);
    int flag = 1;
    while (*format != '\0') {
        if (*format == '%' && *(format+1) != '%' && flag == 1) {
            int temp_len = 0;
            // Если мы попадаем на знак спецификатора %, за которым не следует
            // ещё один знак % и флаг установлен в 1, то мы объявляем структуру
            // cfg, которая содержит информацию о типах всех спецификаторов и флагов
            config cfg;
            // Смещаем указатель на следующую позицию (следующую за %)
            format++;
            // Инициализируем пустую структуру
            s21_initialization(&cfg);
            // Парсим первый спецификатор
            temp_len = s21_reconstruct(&cfg, format);
            format += temp_len;
            // print_struct(&cfg);
            // Если спецификатор формата обнаружен, то запускаем функцию memarg
#if defined __linux__
             if (cfg.type == '\0') {
                 flag = 0;
                 format -= temp_len + 1;
             }
#endif
            end = s21_memarg(end, argptr, &cfg);
        } else {
            // В случае отсутствия спецификаторов просто посимвольно копируем исходную строку
            *end = *format;
            end++;
            *end = '\0';
            flag = 1;
            // Обработка процента
            if (*format == '%' && *(format + 1) == '%') {
                format += 2;
            } else {
                format++;
            }
        }
    }
    *end = '\0';
    va_end(argptr);
    return end - str;
}
